<!DOCTYPE html>
<html>
<body style="background-color:#1A2735">
<head>
    <h3>Build Version: 20230316-1930</h3>
</head>
<script>

const REQUESTS_JSON = [];
const MASTER_SCHEMA = [];
const RELATIONSHIPS = [];
// const RELATIONSHIPS = [{"name":"java-casual/issues/1","parent":[],"related":[],"children":[]}];
const GITHUB_ACCOUNT_PREFIX = "https://github.com/cjcaf1995/";

roll = function () {

    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);
    // const originThis = urlParams.get('this');
    const originThis = "java-casual/issues/1";
    // const command = urlParams.get('command');
    // const commandTokenArr = command.split("_");
    // alert("THIS: " + originThis);
    // if (commandTokenArr.length > 0) {
        //alert("commandTokenArr: " + commandTokenArr);
    //}
    
    let csvCommandListDedup = [];
    const CSV_COMMAND_LIST_COMPLETE = [];
    const CSV_COMMAND_LIST = [];
    CSV_COMMAND_LIST.push("https://github.com/cjcaf1995/intersection/issues/43,S,https://github.com/cjcaf1995/intersection/issues/11");
    CSV_COMMAND_LIST.push("https://github.com/cjcaf1995/intersection/issues/43,C,https://github.com/cjcaf1995/java-casual/issues/1");
    
    // remove duplicates
    csvCommandListDedup = CSV_COMMAND_LIST.sort().filter(function(item, pos, ary) {
        return !pos || item != ary[pos - 1];
    });
    
    // CREATE CORRESPONDING ENTRIES
    csvCommandListDedup.forEach(function(command){
        
        let currOrigin = shortenUrl(command.split(",")[0]);
        let currRel = command.split(",")[1];
        let currTarget = shortenUrl(command.split(",")[2]);
        // alert("currOrigin: " + currOrigin);
        // alert("currRel: " + currRel);
        // alert("currTargetIds: " + currTarget);
        
        let currOrigin_v2 = currTarget;
        let currRel_v2;
        let currTarget_v2 = currOrigin;
        if (currRel === 'P') {
            currRel_v2 = 'C';   
        } else if (currRel === 'S') {
            currRel_v2 = 'S';    
        } else if (currRel === 'C') {
            currRel_v2 = 'P';   
        }
        
        let originalEntry = [currOrigin, currRel, currTarget].join(",");
        let mirrorEntry = [currOrigin_v2, currRel_v2, currTarget_v2].join(",");
        if (!CSV_COMMAND_LIST_COMPLETE.includes(originalEntry)) {
            CSV_COMMAND_LIST_COMPLETE.push(originalEntry);
        }
        if (!CSV_COMMAND_LIST_COMPLETE.includes(mirrorEntry)) {
            CSV_COMMAND_LIST_COMPLETE.push(mirrorEntry);
        }
    });
    
    // alert(CSV_COMMAND_LIST_COMPLETE);
    
    CSV_COMMAND_LIST_COMPLETE.forEach(function(command){
        let currOrigin = shortenUrl(command.split(",")[0]);
        let currRel = command.split(",")[1];
        let currTarget = shortenUrl(command.split(",")[2]);
        // alert("currOrigin: " + currOrigin);
        // alert("currRel: " + currRel);
        // alert("currTargetIds: " + currTarget);
        
        if (currRel === 'P') {
            if (hasRecord(currOrigin)) {
                // alert("hasRecord");
                let existingThis = getRecord(currOrigin);
                existingThis["parent"] = mergeArrays(existingThis["parent"], [currTarget]);
                // alert(JSON.stringify(existingThis));
            } else {
                // alert("noRecord");
                RELATIONSHIPS.push({
                    "name": currOrigin,
                    "parent": [currTarget],
                    "related": [],
                    "children": []
                });
                // alert(JSON.stringify(RELATIONSHIPS));
            }
        }
        
        if (currRel === 'C') {
            if (hasRecord(currOrigin)) {
                // alert("hasRecord");
                let existingThis = getRecord(currOrigin);
                existingThis["children"] = mergeArrays(existingThis["children"], [currTarget]);
                // alert(JSON.stringify(existingThis));
            } else {
                // alert("noRecord");
                RELATIONSHIPS.push({
                    "name": currOrigin,
                    "parent": [],
                    "related": [],
                    "children": [currTarget]
                });
                // alert(JSON.stringify(RELATIONSHIPS));
            }
        }
        
        if (currRel === 'S') {
            if (hasRecord(currOrigin)) {
                // alert("hasRecord");
                let existingThis = getRecord(currOrigin);
                existingThis["related"] = mergeArrays(existingThis["related"], [currTarget]);
                // alert(JSON.stringify(existingThis));
            } else {
                // alert("noRecord");
                RELATIONSHIPS.push({
                    "name": currOrigin,
                    "parent": [],
                    "related": [currTarget],
                    "children": []
                });
                // alert(JSON.stringify(RELATIONSHIPS));
            }
        }
    });
    
    alert(JSON.stringify(RELATIONSHIPS));
    
    
};

window.onload = function() {
    const GITHUB_RAW_PREFIX = "https://raw.githubusercontent.com/";
    const GITHUB_ACCOUNT = "cjcaf1995";
    const GITHUB_REPO = "intersection0915";
    const GITHUB_COMPLETE_PREFIX = GITHUB_RAW_PREFIX + GITHUB_ACCOUNT + "/" + GITHUB_REPO;
    const isProd = false;
    const schemaUrl = isProd ? "schema.json" : GITHUB_COMPLETE_PREFIX + "/main/schema.json";
    const relationshipUrl = isProd ? "relationships.json" : GITHUB_COMPLETE_PREFIX + "/main/relationships.json";
    const requestsUrl = isProd ? "data.json" : GITHUB_COMPLETE_PREFIX + "/main/data.json";
    fetch(schemaUrl)
        .then(response => response.json())
        .then(data => {
            for (var i = 0; i < data.schema.length; i++){
                let currRepositoryEntry = data.schema[i];
                MASTER_SCHEMA.push(currRepositoryEntry);
            }
        });
    document.getElementById('randomButton').click();
}

function shortenUrl(githubUrl) {
    return githubUrl.replaceAll(GITHUB_ACCOUNT_PREFIX, "");
}

processDataJson = function () {
    // 1 Request <--> 1 JSON file
    REQUESTS_JSON.forEach(function(requestObj){
        finalAddRelationship(requestObj); // ------------------ MAIN COMMAND THAT PERFORMS ------------------
    });
    let jsonContent = "data:text/json;charset=utf-8," + JSON.stringify(RELATIONSHIPS);
    var encodedUri = encodeURI(jsonContent);
    // window.open(encodedUri);
    var link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    const currDate = new Date().toISOString().split('T')[0];
    link.setAttribute("download", new Date() + "_RELATIONSHIPS.json");
    document.body.appendChild(link); // Required for FF
    link.click(); // This will download the JSON
}

function randomIntFromInterval(min, max) {
    const randomNumber = Math.random();
    return Math.floor(randomNumber * (Number(max) - Number(min) + 1)) + Number(min);
}

function shuffleArray(array) {
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

function mergeArrays(array1, array2) {
    // merge and remove duplicates
    let mergedArray = array1.concat(array2);
    return mergedArray.filter((item, pos) => mergedArray.indexOf(item) === pos); 
}

function queryRecord(name) {
    return RELATIONSHIPS.find(relationship => {
      return relationship.name === name;
    });
}

function hasRecord(name) {
    let objRel = queryRecord(name);
    return objRel !== undefined;
}

function getRecord(name) {
    return queryRecord(name);
}

function addRelationship(requestObj) {
    let alreadyExisting = hasRecord(requestObj["name"]);
    if (alreadyExisting) {
        // SIMPLE ADDITION
        let existingObj = getRecord(requestObj["name"]);
        existingObj["parent"] = mergeArrays(existingObj["parent"], requestObj["parent"]);
        existingObj["related"] = mergeArrays(existingObj["related"], requestObj["related"]);
        existingObj["children"] = mergeArrays(existingObj["children"], requestObj["children"]);   
    } else {
        RELATIONSHIPS.push(requestObj);
    }

}

finalAddRelationship = function(REQUEST_OBJECT) {
    alert(REQUEST_OBJECT);
}

</script>

<br>
<br>
<br>
<br>
<br>
<div style="text-align:center">
   <button id="randomButton" onclick="roll();">Roll the Dice</button><br><br>
   <button><img src="https://c.statcounter.com/12792249/0/85f97432/0/" alt="Web Analytics"  referrerPolicy="no-referrer-when-downgrade"> Visits(20220904)</button>
</div>

</body>
</html>
